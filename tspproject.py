# -*- coding: utf-8 -*-
"""TSPproject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p2mROvKtIpI4rRmB-N1QD2zr-fe7q2z_
"""

import random
import math

# 10 fixed coordinate points
A = (19, 14)
B = (1, 6)
C = (44, 91)
D = (28, 28)
E = (45, 56)
F = (54, 57)
G = (100, 49)
H = (42, 5)
J = (1, 86)
K = (41, 53)

points = [A, B, C, D, E, F, G, H, J, K]

parent_num = 200
generations = 100
elitism_rate = 0.05
mutation_rate = 0.1

population = []
for _ in range(parent_num):
    new_chromosome = points[:]
    random.shuffle(new_chromosome)
    population.append(new_chromosome)

def calculate_distance(p1, p2):
    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)

def fitness(chromosome):
    total_distance = sum(calculate_distance(chromosome[i], chromosome[i + 1]) for i in range(len(chromosome) - 1))
    total_distance += calculate_distance(chromosome[-1], chromosome[0])
    return total_distance

def tournament_selection(population, fitness_values, k=6, select_ratio=0.3):
    num_parents_to_select = int(len(population) * select_ratio)
    selected_parents = []

    for _ in range(num_parents_to_select):
        selected = random.sample(list(zip(population, fitness_values)), k)
        selected.sort(key=lambda x: x[1])
        selected_parents.append(selected[0][0])

    return selected_parents

def order_crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted([random.randint(0, size - 1) for _ in range(2)])

    child = [None] * size
    child[start:end] = parent1[start:end]

    p2_index = end
    for i in range(size):
        if child[i] is None:
            while parent2[p2_index % size] in child:
                p2_index += 1
            child[i] = parent2[p2_index % size]
            p2_index += 1

    return child

def perform_crossover(selected_parents):
    offsprings = []

    for i in range(0, len(selected_parents), 2):
        parent1 = selected_parents[i]
        parent2 = selected_parents[(i + 1) % len(selected_parents)]

        child1 = order_crossover(parent1, parent2)
        child2 = order_crossover(parent2, parent1)

        offsprings.append(child1)
        offsprings.append(child2)

    return offsprings

def swap_mutation(route):
    idx1, idx2 = random.sample(range(len(route)), 2)
    route[idx1], route[idx2] = route[idx2], route[idx1]
    return route

def swap_mutation_to_offsprings(offsprings, mutation_rate=0.01):
    num_mutations = int(len(offsprings) * mutation_rate)
    mutated_offsprings = offsprings[:]

    for _ in range(num_mutations):
        idx = random.randint(0, len(mutated_offsprings) - 1)
        mutated_offspring = swap_mutation(mutated_offsprings[idx])
        mutated_offsprings[idx] = mutated_offspring

    return mutated_offsprings

for gen in range(generations):
    fitness_values = [fitness(chromosome) for chromosome in population]

    num_elites = max(1, int(parent_num * elitism_rate))
    elites = [chrom for _, chrom in sorted(zip(fitness_values, population), key=lambda x: x[0])][:num_elites]

    selected_parents = tournament_selection(population, fitness_values, k=6, select_ratio=0.3)

    offsprings = perform_crossover(selected_parents)

    mutated_offsprings = swap_mutation_to_offsprings(offsprings, mutation_rate=mutation_rate)

    population = elites + mutated_offsprings

    while len(population) < parent_num:
        new_chromosome = points[:]
        random.shuffle(new_chromosome)
        population.append(new_chromosome)
    population = population[:parent_num]

    if (gen + 1) % 10 == 0:
        best_fitness = min([fitness(chrom) for chrom in population])
        print(f"Generation {gen+1}: Best Fitness = {best_fitness}")

fitness_values = [fitness(chromosome) for chromosome in population]
best_index = fitness_values.index(min(fitness_values))
best_chromosome = population[best_index]
print("\nBest Route:", best_chromosome)
print("Best Fitness (Total Distance):", fitness(best_chromosome))